"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorStorage = void 0;
const idb_1 = require("idb");
const constants_1 = require("./common/constants");
const helpers_1 = require("./common/helpers");
class VectorStorage {
    constructor(options = {}) {
        var _a, _b, _c, _d;
        this.documents = [];
        this.maxSizeInMB = (_a = options.maxSizeInMB) !== null && _a !== void 0 ? _a : constants_1.constants.DEFAULT_MAX_SIZE_IN_MB;
        this.debounceTime = (_b = options.debounceTime) !== null && _b !== void 0 ? _b : constants_1.constants.DEFAULT_DEBOUNCE_TIME;
        this.openaiModel = (_c = options.openaiModel) !== null && _c !== void 0 ? _c : constants_1.constants.DEFAULT_OPENAI_MODEL;
        this.embedTextsFn = (_d = options.embedTextsFn) !== null && _d !== void 0 ? _d : this.embedTexts; // Use the custom function if provided, else use the default one
        this.openaiApiKey = options.openAIApiKey;
        if (!this.openaiApiKey && !options.embedTextsFn) {
            console.error('VectorStorage: pass as an option either an OpenAI API key or a custom embedTextsFn function.');
        }
        else {
            this.loadFromIndexDbStorage();
        }
    }
    addText(text, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            // Create a document from the text and metadata
            const doc = {
                metadata,
                text,
                timestamp: Date.now(),
                vector: [],
                vectorMag: 0,
            };
            const docs = yield this.addDocuments([doc]);
            return docs[0];
        });
    }
    addTexts(texts, metadatas) {
        return __awaiter(this, void 0, void 0, function* () {
            if (texts.length !== metadatas.length) {
                throw new Error('The lengths of texts and metadata arrays must match.');
            }
            const docs = texts.map((text, index) => ({
                metadata: metadatas[index],
                text,
                timestamp: Date.now(),
                vector: [],
                vectorMag: 0,
            }));
            return yield this.addDocuments(docs);
        });
    }
    similaritySearch(params) {
        return __awaiter(this, void 0, void 0, function* () {
            const { query, k = 4, filterOptions, includeValues } = params;
            const queryEmbedding = yield this.embedText(query);
            const queryMagnitude = yield this.calculateMagnitude(queryEmbedding);
            const filteredDocuments = (0, helpers_1.filterDocuments)(this.documents, filterOptions);
            const scoresPairs = this.calculateSimilarityScores(filteredDocuments, queryEmbedding, queryMagnitude);
            const sortedPairs = scoresPairs.sort((a, b) => b[1] - a[1]);
            const results = sortedPairs.slice(0, k).map((pair) => (Object.assign(Object.assign({}, pair[0]), { score: pair[1] })));
            this.updateHitCounters(results);
            if (results.length > 0) {
                this.removeDocsLRU();
                yield this.saveToIndexDbStorage();
            }
            if (!includeValues) {
                results.forEach((result) => {
                    delete result.vector;
                    delete result.vectorMag;
                });
            }
            return {
                query: { embedding: queryEmbedding, text: query },
                similarItems: results,
            };
        });
    }
    initDB() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, idb_1.openDB)('VectorStorageDatabase', undefined, {
                upgrade(db) {
                    const documentStore = db.createObjectStore('documents', {
                        autoIncrement: true,
                        keyPath: 'id',
                    });
                    documentStore.createIndex('text', 'text', { unique: true });
                    documentStore.createIndex('metadata', 'metadata');
                    documentStore.createIndex('timestamp', 'timestamp');
                    documentStore.createIndex('vector', 'vector');
                    documentStore.createIndex('vectorMag', 'vectorMag');
                    documentStore.createIndex('hits', 'hits');
                },
            });
        });
    }
    addDocuments(documents) {
        return __awaiter(this, void 0, void 0, function* () {
            // filter out already existing documents
            const newDocuments = documents.filter((doc) => !this.documents.some((d) => d.text === doc.text));
            // If there are no new documents, return an empty array
            if (newDocuments.length === 0) {
                return [];
            }
            const newVectors = yield this.embedTextsFn(newDocuments.map((doc) => doc.text));
            // Assign vectors and precompute vector magnitudes for new documents
            newDocuments.forEach((doc, index) => {
                doc.vector = newVectors[index];
                doc.vectorMag = calcVectorMagnitude(doc);
            });
            // Add new documents to the store
            this.documents.push(...newDocuments);
            this.removeDocsLRU();
            // Save to index db storage
            yield this.saveToIndexDbStorage();
            return newDocuments;
        });
    }
    embedTexts(texts) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(constants_1.constants.OPENAI_API_URL, {
                body: JSON.stringify({
                    input: texts,
                    model: this.openaiModel,
                }),
                headers: {
                    Authorization: `Bearer ${this.openaiApiKey}`,
                    'Content-Type': 'application/json',
                },
                method: 'POST',
            });
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const responseData = (yield response.json());
            return responseData.data.map((data) => data.embedding);
        });
    }
    embedText(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.embedTextsFn([query]))[0];
        });
    }
    calculateMagnitude(embedding) {
        const queryMagnitude = Math.sqrt(embedding.reduce((sum, val) => sum + val * val, 0));
        return queryMagnitude;
    }
    calculateSimilarityScores(filteredDocuments, queryVector, queryMagnitude) {
        return filteredDocuments.map((doc) => {
            const dotProduct = doc.vector.reduce((sum, val, i) => sum + val * queryVector[i], 0);
            let score = getCosineSimilarityScore(dotProduct, doc.vectorMag, queryMagnitude);
            score = normalizeScore(score); // Normalize the score
            return [doc, score];
        });
    }
    updateHitCounters(results) {
        results.forEach((doc) => {
            var _a;
            doc.hits = ((_a = doc.hits) !== null && _a !== void 0 ? _a : 0) + 1; // Update hit counter
        });
    }
    loadFromIndexDbStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                this.db = yield this.initDB();
            }
            this.documents = yield this.db.getAll('documents');
            this.removeDocsLRU();
        });
    }
    saveToIndexDbStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.db) {
                this.db = yield this.initDB();
            }
            try {
                const tx = this.db.transaction('documents', 'readwrite');
                yield tx.objectStore('documents').clear();
                for (const doc of this.documents) {
                    // eslint-disable-next-line no-await-in-loop
                    yield tx.objectStore('documents').put(doc);
                }
                yield tx.done;
            }
            catch (error) {
                console.error('Failed to save to IndexedDB:', error.message);
            }
        });
    }
    removeDocsLRU() {
        if ((0, helpers_1.getObjectSizeInMB)(this.documents) > this.maxSizeInMB) {
            // Sort documents by hit counter (ascending) and then by timestamp (ascending)
            this.documents.sort((a, b) => { var _a, _b; return ((_a = a.hits) !== null && _a !== void 0 ? _a : 0) - ((_b = b.hits) !== null && _b !== void 0 ? _b : 0) || a.timestamp - b.timestamp; });
            // Remove documents until the size is below the limit
            while ((0, helpers_1.getObjectSizeInMB)(this.documents) > this.maxSizeInMB) {
                this.documents.shift();
            }
        }
    }
}
exports.VectorStorage = VectorStorage;
function calcVectorMagnitude(doc) {
    return Math.sqrt(doc.vector.reduce((sum, val) => sum + val * val, 0));
}
function getCosineSimilarityScore(dotProduct, magnitudeA, magnitudeB) {
    return dotProduct / (magnitudeA * magnitudeB);
}
function normalizeScore(score) {
    return (score + 1) / 2;
}
