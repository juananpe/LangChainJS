"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debounce = exports.getObjectSizeInMB = exports.filterDocuments = exports.getCosineSimilarityScore = exports.calcVectorMagnitude = void 0;
function calcVectorMagnitude(doc) {
    return Math.sqrt(doc.vector.reduce((sum, val) => sum + val * val, 0));
}
exports.calcVectorMagnitude = calcVectorMagnitude;
function getCosineSimilarityScore(dotProduct, magnitudeA, magnitudeB) {
    return dotProduct / (magnitudeA * magnitudeB);
}
exports.getCosineSimilarityScore = getCosineSimilarityScore;
function filterDocuments(documents, filterOptions) {
    let filteredDocuments = documents;
    if (filterOptions) {
        if (filterOptions.include) {
            filteredDocuments = filteredDocuments.filter((doc) => matchesCriteria(doc, filterOptions.include));
        }
        if (filterOptions.exclude) {
            filteredDocuments = filteredDocuments.filter((doc) => !matchesCriteria(doc, filterOptions.exclude));
        }
    }
    return filteredDocuments;
}
exports.filterDocuments = filterDocuments;
function matchesCriteria(document, criteria) {
    if (criteria.metadata) {
        for (const key in criteria.metadata) {
            // @ts-expect-error
            if (document.metadata[key] !== criteria.metadata[key]) {
                return false;
            }
        }
    }
    if (criteria.text) {
        const texts = Array.isArray(criteria.text) ? criteria.text : [criteria.text];
        if (!texts.includes(document.text)) {
            return false;
        }
    }
    return true;
}
function getObjectSizeInMB(obj) {
    const bytes = JSON.stringify(obj).length;
    const kilobytes = bytes / 1024;
    return kilobytes / 1024;
}
exports.getObjectSizeInMB = getObjectSizeInMB;
// export function cosineSimilarity(vecA: number[], vecB: number[]): number {
//   const dotProduct = vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);
//   const magnitudeA = Math.sqrt(vecA.reduce((sum, val) => sum + val * val, 0));
//   const magnitudeB = Math.sqrt(vecB.reduce((sum, val) => sum + val * val, 0));
//   return getCosineSimilarityScore(dotProduct, magnitudeA, magnitudeB);
// }
function debounce(func, delay) {
    let timeoutId;
    // eslint-disable-next-line func-names
    return function () {
        if (timeoutId) {
            clearTimeout(timeoutId);
        }
        // @ts-expect-error
        timeoutId = setTimeout(() => {
            // eslint-disable-next-line no-invalid-this
            func.apply(this);
        }, delay);
    };
}
exports.debounce = debounce;
